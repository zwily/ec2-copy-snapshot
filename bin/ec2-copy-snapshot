#!/usr/bin/env ruby
# encoding: UTF-8

require 'rubygems'
require 'optparse'
require 'aws-sdk'
require 'net/ssh'

opts = {
  :aws_access_key => ENV["AWS_ACCESS_KEY_ID"],
  :aws_secret_access_key => ENV["AWS_SECRET_ACCESS_KEY"],
  :source_aws_region => 'us-east-1',
  :destination_aws_region => nil,
  :snapshot_id => nil,
  :source_hostname => nil,
  :destination_hostname => nil,
  :keep_destination_volume => false,
}

parser = OptionParser.new do |o|
  o.banner = "Usage: copy_snapshot_between_regions [options] snapshot-id"

  o.on("--aws-access-key ACCESS_KEY", "AWS Access Key (default: AWS_ACCESS_KEY_ID)") do |v|
    opts[:aws_access_key] = v
  end

  o.on("--aws-secret-access-key SECRET_KEY", "AWS Secret Access Key (default: AWS_SECRET_ACCESS_KEY)") do |v|
    opts[:aws_secret_access_key] = v
  end

  o.on("--from-region REGION", "AWS Region to copy snapshot FROM (default: us-east-1)") do |v|
    opts[:source_aws_region] = v
  end

  o.on("--to-region REGION", "AWS Region to copy snapshot TO") do |v|
    opts[:destination_aws_region] = v
  end

  o.on("--from-instance HOSTNAME", "Hostname of an instance in the source region to use for the copy") do |v|
    opts[:source_hostname] = v
  end

  o.on("--to-instance HOSTNAME", "Hostname of an instance in the target region to use for the copy") do |v|
    opts[:destination_hostname] = v
  end

  o.on("--[no-]keep-volume", "Keep the destination volume the new snapshot is made from (default: no)") do |v|
    opts[:keep_destination_volume] = v
  end
end
parser.parse!

if ARGV.length == 1
  opts[:snapshot_id] = ARGV.shift
end

if opts.values.any? {|v| v.nil? }
  puts parser.help
  exit 1
end

STDOUT.sync = true

ec2 = AWS::EC2.new(:access_key_id => opts[:aws_access_key], :secret_access_key => opts[:aws_secret_access_key])
ec2_source = ec2.regions[opts[:source_aws_region]]
ec2_destination = ec2.regions[opts[:destination_aws_region]]

def wait_for(interval = 5, &block)
  while true
    print "."
    sleep interval
    break if yield
  end
end

def available_dev(instance)
  # Returns a device that appears to be unused. There is a race condition here
  # if several people are using this script with the same instances at the same
  # time, but worst case the script will fail when we try to attach to a device
  # that somebody else has started using.
  device_mappings = instance.block_device_mappings
  possible_devs = ('f'..'z').to_a.map {|l| "/dev/sd#{l}" } - device_mappings.keys
  return nil if possible_devs.empty?
  possible_devs.sample
end

def wait_for_volume(volume, desc)
  print "Waiting for #{desc} volume #{volume.id}..."
  wait_for { volume.status != :creating }
  puts "done."

  if volume.status != :available
    raise "Volume is not available (#{volume.status})"
  end
end

def attach_volume_to_instance(volume, instance, desc)
  dev = available_dev(instance)
  if dev.nil?
    raise "Can't find a dev on #{instance.id}"
  end

  puts "Attaching #{desc} volume to instance #{instance.id} at #{dev}..."
  attachment = volume.attach_to(instance, dev)
  return attachment
end

def wait_for_attachment(attachment, desc)
  print "Waiting for #{desc} volume to be attached..."
  wait_for { attachment.status != :attaching }
  puts "done."

  if attachment.status != :attached
    raise "Volume did not successfully attach (#{attachment.status})"
  end
end

def detach_attachment(attachment, desc)
  puts "Detaching #{desc} #{attachment.volume.id}"
  attachment.delete(:force => true)
end

def wait_for_detachment(attachment, desc)
  print "Waiting for #{desc} volume to be detached..."
  volume = attachment.volume
  wait_for { volume.status != :in_use }
  puts "done."

  if attachment.volume.status != :available
    raise "Volume did not successfully detach #{attachment.volume.status})"
  end
end

def delete_volume(volume, desc)
  puts "Deleting #{desc} #{volume.id}..."
  volume.delete
end

def mangled_dev(dev)
  # Newer versions of Linux address the sdX volumes as xvdX
  dev.gsub('/dev/sd', '/dev/xvd')
end

begin
  print "Logging into #{opts[:source_hostname]}..."
  source_ssh = Net::SSH.start(opts[:source_hostname], nil)
  source_instance_id = source_ssh.exec!("curl -s http://169.254.169.254/latest/meta-data/instance-id")
  source_instance = ec2_source.instances[source_instance_id]
  puts " #{source_instance_id}"

  print "Logging into #{opts[:destination_hostname]}..."
  destination_ssh = Net::SSH.start(opts[:destination_hostname], nil)
  destination_instance_id = destination_ssh.exec!("curl -s http://169.254.169.254/latest/meta-data/instance-id")
  destination_instance = ec2_destination.instances[destination_instance_id]
  puts " #{destination_instance_id}"

  puts "Getting snapshot information..."
  source_snapshot = ec2_source.snapshots[opts[:snapshot_id]]
  if source_snapshot.status != :completed
    raise "Snapshot does not appear complete (#{source_snapshot.status})"
  end

  print "Creating a volume from the snapshot..."
  source_volume = source_snapshot.create_volume(source_instance.availability_zone)
  puts " #{source_volume.id}"

  print "Creating a destination volume..."
  destination_volume = ec2_destination.volumes.create(
    :size => source_volume.size,
    :availability_zone => destination_instance.availability_zone)
  puts " #{destination_volume.id}"

  wait_for_volume(source_volume, "source")
  wait_for_volume(destination_volume, "destination")

  source_attachment = attach_volume_to_instance(source_volume, source_instance, "source")
  destination_attachment = attach_volume_to_instance(destination_volume, destination_instance, "destination")

  wait_for_attachment(source_attachment, "source")
  wait_for_attachment(destination_attachment, "destination")

  puts "Copying data from source to destination, this may take awhile..."
  source_ssh.exec!(%Q{
    catcmd="cat"; if [[ $(which pv) ]]; then catcmd="pv -f"; fi; \
    sudo $catcmd #{mangled_dev(source_attachment.device)} | dd bs=1M | bzip2 --compress | \
    ssh root@#{opts[:destination_hostname]} "bzip2 --decompress | dd of=#{mangled_dev(destination_attachment.device)} bs=1M"
  }) do |channel, stream, data|
    STDOUT.print data if stream == :stdout
    STDERR.print data if stream == :stderr
  end

  print "Creating snapshot of new volume..."
  destination_snapshot = destination_volume.create_snapshot("created by #{`whoami`} of #{opts[:snapshot_id]} from #{opts[:source_aws_region]}")
  puts " #{destination_snapshot.id}"

  print "Waiting for snapshot to complete..."
  wait_for { destination_snapshot.status != :pending }
  puts "done."

  if destination_snapshot.status != :completed
    raise "Could not create snapshot (#{destination_snapshot.status})"
  end
ensure
  puts "Cleaning up..."

  # Start detaching the source and dest volumes in parallel, cause they might take awhile
  detach_attachment(source_attachment, "source") if source_attachment
  detach_attachment(destination_attachment, "destination") if destination_attachment && !opts[:keep_destination_volume]

  wait_for_detachment(source_attachment, "source") if source_attachment
  wait_for_detachment(destination_attachment, "destination") if destination_attachment && !opts[:keep_destination_volume]

  delete_volume(source_volume, "source") if source_volume
  delete_volume(destination_volume, "destination") if destination_volume && !opts[:keep_destination_volume]

  puts "Closing SSH connections..."
  destination_ssh.close if destination_ssh
  source_ssh.close if source_ssh
end

puts "New snapshot created: #{destination_snapshot.id}" if destination_snapshot
